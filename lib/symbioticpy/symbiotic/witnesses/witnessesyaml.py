#!/usr/bin/python

from os.path import basename
from hashlib import sha256 as hashfunc
import subprocess
import datetime
import re
import yaml

no_lxml = False
try:
    from lxml import etree as ET
except ImportError:
    no_lxml = True
if no_lxml:
    # if this fails, then we're screwed, so let the script die
    from xml.etree import ElementTree as ET

def get_hash(source):
    f = open(source, 'r', encoding='utf-8')
    hsh = hashfunc()
    for l in f:
        hsh.update(l.encode('utf-8'))

    f.close()
    return hsh.hexdigest()

def _add_edge_key(root, name):
    e = ET.SubElement(root, 'key', id=name)
    e.set('for', 'edge')
    e.set('attr.type', 'string')
    e.set('attr.name', name)

def _add_node_key(root, name):
    e = ET.SubElement(root, 'key', id=name)
    e.set('for', 'node')
    e.set('attr.type', 'string')
    e.set('attr.name', name)

def _add_graph_key(root, name):
    e = ET.SubElement(root, 'key', id=name)
    e.set('for', 'graph')
    e.set('attr.type', 'string')
    e.set('attr.name', name)

class YAMLWriter(object):
    def __init__(self, source, prps, is32bit, is_correctness_wit):
        self._source = source
        self._prps = prps
        self._is32bit = is32bit
        self._correctness_wit = is_correctness_wit

        self.test = []
        self.errorLoc = None
        self.witness = []

        self._root = None
        self._graph = None

        # this prevents adding ns0 prefix to all tags
        ET.register_namespace("xsi",
                              "http://www.w3.org/2001/XMLSchema-instance")

    def add_metadata(self):
        witness = {}
        witness['entry_type'] = "violation_sequence" if not self._correctness_wit else "correctness_witness"
        witness['metadata'] = {
            'format_version' : "0.1",
            'creation_time' :  '{date:%Y-%m-%dT%T}Z'.format(date=datetime.datetime.utcnow()),
            'producer' : {'name' : 'symbiotic'},
            'task' :
                { 'input_files' : self._source,
                  'input_file_hashes' : { self._source : get_hash(self._source)},
                  'specification' : ','.join(self._prps),
                  'data_model' : "ILP32" if self._is32bit else "LP64",
                  'language' : "C"}
        }
        self.witness.append(witness)


    def generate_witness(self, path, is_termination):
        """
        Take a .graphml file generated by a tool and generate a new
        .graphml file from it that has all the needed metadata.

        \param path         the .test file
        """
        # parse the graphml file from KLEE
        self.parse(path)
        assert self.errorLoc, "Failed parsing a witness" + path 

        self.add_metadata()
        self.create_content()



    def generate_violation_witness(self, path, is_termination):
        self.generate_witness(path, is_termination)

    def dump(self):
        if no_lxml:
            print(ET.tostring(self._root).decode('utf-8'))
        else:
            print(ET.tostring(self._root, pretty_print=True).decode('utf-8'))

    def write(self, to):
        with open(to, "w") as witness_file:
            yaml.safe_dump(self.witness, witness_file, default_style=None)
 
    def get_locations(self):
        this_file = True
        shifterror = True
        call_map = dict()
        ast = subprocess.run(['clang', '-Xclang', '-ast-dump', '-fsyntax-only', '-fno-color-diagnostics', self._source], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL).stdout.decode('utf-8')
        
        for line in ast.splitlines():
            
            # check if we have a begin and end
            loc = re.search("^[^-]*-[a-zA-Z]* 0x[0-9A-Fa-f]* <([^>,]*), ([^,]*)>", line)

            if not loc:  # if not, we only care about the line
                ln = re.search("^[^-]*-[a-zA-Z]* 0x[0-9A-Fa-f]* <line:([0-9]*)", line)
                if ln:
                    last_ln = ln[1]
                continue

            start = loc[1]
            end = loc[2]

            location = re.search("([^:]*):([0-9]*):([0-9]*)", start)
            if not location:
                if not this_file:
                    continue

                # if there's no line specified, use the previous one
                start_ln = last_ln
                start_col = re.search("col:([0-9]*)", start)[1]
            else:
                name = location[1]
                start_ln = location[2]
                start_col = location[3]

            # if there is a filename, check if its the program under validation - we do not care about headers
            if name and name != "line":
                if name != self._source:
                    this_file = False
                    continue
            else:
                this_file = True

            # update last line
            last_ln = start_ln

            # again, check if there's a line number, otherwise use previous
            if "line" in end:
                end_loc = re.search("line:([0-9]*):([0-9]*)", end)
                end_ln, end_col = end_loc[1], end_loc[2]
            else:
                end_ln = last_ln
                end_col = re.search("col:([0-9]*)", end)[1]

            last_ln = end_ln

            start_location = start_ln + ":" + start_col
            end_location = end_ln + ":" + end_col

            # index callmap by end location
            if "CallExpr" in line:
                if start_location not in call_map:
                    call_map[start_location] = end_location

            if not shifterror or "FunctionDecl" in line \
                or "CompoundStmt" in line \
                or "IfStmt" in line \
                or "DoStmt" in line \
                or "WhileStmt" in line \
                or "ForStmt" in line \
                or "LabelStmt" in line:
                continue

            if int(start_ln) > int(self.errorLoc[1]) or int(end_ln) < int(self.errorLoc[1]):
                continue

            if (int(start_ln) == int(self.errorLoc[1]) and int(start_col) > int(self.errorLoc[2])) or \
                (int(end_ln) == int(self.errorLoc[1]) and int(end_col) < int(self.errorLoc[2])):
                continue

            
            self.errorLoc[1] = int(start_ln)
            self.errorLoc[2] = int(start_col)
            shifterror = False

        if shifterror:
            print("Something went wrong. Error location might not comply with the witness format.")
            self.errorLoc[1] = int(self.errorLoc[1])
            self.errorLoc[2] = int(self.errorLoc[2])
  
        return call_map

    def create_content(self):
        content = []

        call_map = self.get_locations()

        for call in self.test:
            loc = "{line}:{col}".format(line=call[1], col=call[2])
            assert loc in call_map, "Failed creating witness"
            call[1], call[2] = map(int, call_map[loc].split(':'))
            segment = []
            waypoint = { 'type' : 'function_return',
                          'action' : 'follow',
                          'constraint' : {
                            'format' : 'C',
                            'string' : '\\result == ' + call[3]
                          },
                          'location' : {
                            'file_name' : self._source,
                            'line' : call[1],
                            'column' : call[2]
                          }

                        }
            segment.append({'waypoint' : waypoint})
            content.append({'segment' : segment})

        target_segment = []
        target = { 'type' : 'target',
                   'action' : 'follow',
                   'location' : {
                            'file_name' : self.errorLoc[0],
                            'line' : self.errorLoc[1],
                            'column' : self.errorLoc[2]
                          }

                 }
            
        target_segment.append({'waypoint' : target})
        content.append({'segment' : target_segment})

        self.witness[0]['content'] = content



    def parse(self, path):
        with open(path, "r") as testfile:
            for line in testfile.readlines():
                if line[0] == '@':
                    self.errorLoc = line.strip('\n').split(':')[1:]
                    break
                self.test.append(line.strip('\n').split(':'))

